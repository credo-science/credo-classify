from typing import List, Dict, Any, Callable, Optional, Tuple

from hit_analysis.commons.consts import DEVICE_ID, TIMESTAMP, CLASSIFIED, CLASS_ARTIFACT
from hit_analysis.commons.utils import get_and_set, get_resolution_key


def group_by_lambda(array: List[Any], func: Callable[[Any, Dict[Any, List[Any]]], Any], exclusion: Optional[Callable[[Any], bool]] = None) -> Dict[Any, List[Any]]:
    """
    Convert list of objects to dict of list of object when key of dict is generated by func.
    :param array: list of objects
    :param func: give object as param and return key or None, when key is None then object will be excluded
    :param exclusion: when is not None and return True then object will be ignored
    :return: dict of list of object
    """
    ret = {}
    for o in array:
        if exclusion is None or not exclusion(o):
            key = func(o, ret)
            os = get_and_set(ret, key, [])
            os.append(o)
    return ret


def exclude_artifacts(detection: dict):
    """
    Exclusion classified as artifact.
    :param detection: detection
    :return: detection['classified'] == 'artifact'
    """
    return detection.get(CLASSIFIED) == CLASS_ARTIFACT


def group_by_device_id(detections: List[dict], exclusion: Optional[Callable[[Any], bool]] = None) -> Dict[int, List[dict]]:
    """
    Group detections by device_id field.
    :param detections: list of detections
    :param exclusion: when is not None and return True then object will be ignored
    :return: detections grouped by device_id
    """
    return group_by_lambda(detections, lambda x, y: x.get(DEVICE_ID), exclusion)


def group_by_timestamp_division(detections: List[dict], division: int, exclusion: Optional[Callable[[Any], bool]] = None) -> Dict[int, List[dict]]:
    """
    Group detections by timestamp divided
    :param detections: list of ungrouped detections
    :param division: timestamp window do divide detections
    :param exclusion: when is not None and return True then object will be ignored
    :return: detection grouped by timestamp integer divided by division param
    """
    return group_by_lambda(detections, lambda x, y: x.get(TIMESTAMP) // division, exclusion)


def group_by_resolution(detections: List[dict], exclusion: Optional[Callable[[dict], bool]] = None) -> Dict[Tuple[int, int], List[dict]]:
    """
    Group detections by resolution of frame
    :param detections: list of ungrouped detections
    :param exclusion:
    :return: when is not None and return True then object will be ignored
    """
    return group_by_lambda(detections, lambda x, y: get_resolution_key(x), exclusion)


def sort_by_field(detections: List[dict], field: str) -> List[dict]:
    """
    Sort detections by field.
    :param detections: list of detections
    :param field: field for sort by
    :return: list of detections sorted by field
    """
    return sorted(detections, key=lambda i: i[field])
